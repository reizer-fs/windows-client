<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>

<glsl_hacker>
<!--
msaa="Off"
msaa="2X MSAA"
msaa="4X MSAA"
msaa="8X MSAA"
-->	
  <window name="win3d01" title="Spherical Env Mapping Demo" 
          width="800" height="600" msaa="Off" color_bits="32" depth_bits="24"
          gl_version_major="3" gl_version_minor="2" gl_core_profile="0"/>

  
	<script name="init_scene" run_mode="INIT" >
		<raw_data><![CDATA[	
    
    
local demo_dir = gh_utils.get_demo_dir()
local framework_dir = demo_dir .. "../framework/"
dofile(framework_dir .. "framework_gl.lua")


GL_Framework_Init_Begin(framework_dir)

GL_Framework_Set_Main_Title("OpenGL 3.2 / Spherical Env Mapping")
   
    
    
camera = GL_Framework_Get_Camera()
gh_camera.set_position(camera, 0, 0, 20)
gh_camera.set_lookat(camera, 0, 0, 0, 1)




sphere_env_mapping_prog01 = gh_node.getid("sphere_env_mapping_prog01")

gh_gpu_program.bind(sphere_env_mapping_prog01)
gh_gpu_program.uniform1i(sphere_env_mapping_prog01, "tex0", 0)
-- gh_gpu_program.uniform1i(sphere_env_mapping_prog01, "tex1", 1)
gh_gpu_program.bind(0)




angle = 0.2
steps = 512
facets = 32
--scale = 1.5 + math.sin(angle) / 2
scale = 4.0
thickness = 1.0
clumps = 2
clump_offset = angle * 30
clump_scale = 0.4
u_scale = 2
v_scale = 32
P = 3
Q = 2
mesh_knot1 = gh_mesh.create_pqtorus(steps, facets, scale, thickness, clumps, clump_offset, clump_scale, u_scale, v_scale, P, Q)


angle = 0.2
steps = 512
facets = 32
--scale = 1.5 + math.sin(angle) / 2
scale = 4.0
thickness = 1.0
clumps = 2
clump_offset = angle * 30
clump_scale = 0.4
u_scale = 2
v_scale = 32
P = 4
Q = 3
mesh_knot2 = gh_mesh.create_pqtorus(steps, facets, scale, thickness, clumps, clump_offset, clump_scale, u_scale, v_scale, P, Q)


mesh_torus = gh_mesh.create_torus(8, 1, 50)
gh_object.setpos(mesh_torus, 0, 0, 0)

mesh_sphere = gh_mesh.create_sphere(6, 30, 30)
gh_object.setpos(mesh_sphere, 0, 0, 0)

local abs_path = 0
tex01 = gh_texture.create_from_file("matcap2.jpg", 0, abs_path)
tex02 = gh_texture.create_from_file("matcap3.jpg", 0, abs_path)
--tex0 = gh_texture.create_from_file("grace_probe.jpg", 0, abs_path)


gh_renderer.vsync(0)
gh_renderer.enable_state("GL_MULTISAMPLE")
--gh_renderer.msaa(1)

GL_SAMPLE_BUFFERS = gh_renderer.get_capability_4i("GL_SAMPLE_BUFFERS")
GL_SAMPLES = gh_renderer.get_capability_4i("GL_SAMPLES")





GL_Framework_Init_End()

		]]></raw_data>
	</script> 

  
  
  
  
  
	<script name="kill_scene" run_mode="TERMINATE" >
		<raw_data><![CDATA[	

GL_Framework_Terminate()

		]]></raw_data>
	</script> 
  
  




  
  
	<script name="update_scene" run_mode="FRAME" >
		<raw_data><![CDATA[	

-----------------------------------------------------------------------
GL_Framework_Frame_Begin(0.3, 0.3, 0.3)
-----------------------------------------------------------------------
    

local elapsed_time = GL_Framework_GetTime()
    
    

    
local cx = 0
local cy = 0
local cz = 20
    
--local cx = 20 * math.cos(elapsed_time * 1.0)
--local cy = 2
--local cz = 20 * math.sin(elapsed_time * 1.5)
-- gh_camera.set_position(camera._id, cx, cy, cz)
-- gh_camera.set_lookat(camera._id, 0, 0, 0, 1)
-- gx_camera.update(camera, dt)
-- gh_camera.bind(camera._id)

gh_camera.set_position(camera, cx, cy, cz)
gh_camera.set_lookat(camera, 0, 0, 0, 1)
gh_camera.bind(camera)


gh_renderer.set_depth_test_state(1)

if (sphere_env_mapping_prog01 > 0) then
	gh_gpu_program.bind(sphere_env_mapping_prog01)

gh_texture.bind(tex01, 0)
-- gh_gpu_program.uniform4f(sphere_env_mapping_prog01, "uv_tiling", 1.0, 1.0, 1.0, 1.0)
gh_object.setpos(mesh_knot1, -8, 0, 0)
gh_object.set_euler_angles(mesh_knot1, elapsed_time*20, elapsed_time*50, elapsed_time*10)
gh_object.render(mesh_knot1)

gh_texture.bind(tex02, 0)
--gh_gpu_program.uniform4f(sphere_env_mapping_prog01, "uv_tiling", 2.0, 2.0, 1.0, 1.0)
gh_object.setpos(mesh_knot2, 8, 0, 0)
gh_object.set_euler_angles(mesh_knot2, elapsed_time*20, -elapsed_time*50, elapsed_time*10)
gh_object.render(mesh_knot2)
    
end
    
    
-----------------------------------------------------------------------
GL_Framework_Frame_End(1)
-----------------------------------------------------------------------
    
		]]></raw_data>
	</script> 
	

	<script name="resize_scene" run_mode="SIZE" >
		<raw_data><![CDATA[	

GL_Framework_Resize()


		]]></raw_data>
	</script> 
  

          
          
          
          
          
<gpu_program name="sphere_env_mapping_prog01" >
    <raw_data_vs><![CDATA[	 
#version 150
in vec4 gxl3d_Position;
in vec4 gxl3d_Normal;
in vec4 gxl3d_TexCoord0;

out vec4 Vertex_UV_env;

uniform mat4 gxl3d_ModelViewProjectionMatrix; // Automatically passed by GLSL Hacker
uniform mat4 gxl3d_ModelViewMatrix; // Automatically passed by GLSL Hacker
uniform vec4 uv_tiling;
void main()
{
  gl_Position = gxl3d_ModelViewProjectionMatrix * gxl3d_Position;

  vec4 n = normalize(gxl3d_ModelViewMatrix  * gxl3d_Normal);
  vec4 e = gxl3d_ModelViewMatrix * gxl3d_Position;
  
  // GLSL reflect is not supported on Crimson 16.5.3 + Radeon HD 7970:
  // [OpenGL] GPU program (sphere_env_mapping_prog01) linking info log - Vertex shader(s) failed to link.
  // Vertex link error: HW_UNSUPPORTED.
  // ERROR: Internal compile error, error code: E_SC_LITERAL_NOT_DEFINED
  // Shader not supported by HW
  //
  //vec4 r = reflect(e, n);
  vec4 r = e - 2.0 * dot(e, n) * n;
  
  // pow() does not work well on Linux/Gallium.
  //float m = 2. * sqrt(pow(r.x, 2.) + pow(r.y, 2.) + pow(r.z + 1., 2.));
  float m = 2. * sqrt((r.x*r.x) + (r.y*r.y) + ((r.z + 1.)*(r.z + 1.)));
  Vertex_UV_env.xy = r.xy / (m+.001) + .5;  
  Vertex_UV_env.zw = vec2(.0, .0);
  
}
  ]]></raw_data_vs>
    <raw_data_ps><![CDATA[	 
#version 150
uniform sampler2D tex0;
in vec4 Vertex_UV_env;
out vec4 FragColor;
void main()
{
  vec2 uv = Vertex_UV_env.xy;
  uv.y *= -1.;
  vec4 tex0_color = texture(tex0, uv).rgba;
  FragColor.rgb = tex0_color.rgb;
  FragColor.a = 1.0;
}    ]]></raw_data_ps>
  </gpu_program>
  
  
  
  
 <!--
<gpu_program name="sphere_env_mapping_prog02" >
    <raw_data_vs><![CDATA[	 
#version 150
in vec4 gxl3d_Position;
in vec4 gxl3d_Normal;
in vec4 gxl3d_TexCoord0;

out vec4 Vertex_UV;
out vec4 Vertex_UV_env;

uniform mat4 gxl3d_ModelViewProjectionMatrix; // Automatically passed by GLSL Hacker
uniform mat4 gxl3d_ModelViewMatrix; // Automatically passed by GLSL Hacker
uniform vec4 uv_tiling;
void main()
{
  gl_Position = gxl3d_ModelViewProjectionMatrix * gxl3d_Position;
  Vertex_UV = gxl3d_TexCoord0 * uv_tiling;

  vec4 n = gxl3d_ModelViewMatrix  * gxl3d_Normal;
  vec4 e = gxl3d_ModelViewMatrix * gxl3d_Position;
    
  vec4 r = reflect(e, n);
  float m = 2. * sqrt(pow(r.x, 2.) + pow(r.y, 2.) + pow(r.z + 1., 2.));
  Vertex_UV_env.xy = r.xy / m + .5;  
  Vertex_UV_env.zw = vec2(.0, .0);
}
  ]]></raw_data_vs>
    <raw_data_ps><![CDATA[	 
#version 150
precision highp float;
uniform sampler2D tex0;
uniform sampler2D tex1;
in vec4 Vertex_UV;
in vec4 Vertex_UV_env;
out vec4 FragColor;

void main()
{
  vec2 uv = Vertex_UV_env.xy;
  uv.y *= -1.;
  vec4 tex0_color = texture(tex0, uv).rgba;
  uv = Vertex_UV.xy;
  uv.y *= -1.;
  vec4 tex1_color = texture(tex1, uv).rgba;
  FragColor.rgb = (tex0_color.rgb * 0.4) + (tex1_color.rgb * 0.6);
  FragColor.a = 1.0;
}    ]]></raw_data_ps>
  </gpu_program>
-->

  
</glsl_hacker>
